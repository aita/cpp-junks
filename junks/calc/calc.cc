/* Generated by re2c 2.0.3 on Mon Feb  8 09:37:43 2021 */
#include <cassert>
#include <cstring>
#include <fstream>
#include <iostream>
#include <memory>

#define YYMAXFILL 1


enum TokenKind {
  kEOF,
  kInt,
  kAdd,
  kSub,
  kMul,
  kDiv,
  kNewline,
  kError,
};

class Scanner {
 public:
  Scanner(std::ifstream&& fs, std::size_t buffer_size = 1024)
      : fs_(std::move(fs)),
        eof_(false),
        buffer_size_(buffer_size),
        buffer_(new unsigned char[buffer_size]),
        cursor_(&buffer_[0] + buffer_size),
        marker_(&buffer_[0] + buffer_size),
        token_(&buffer_[0] + buffer_size),
        limit_(&buffer_[0] + buffer_size) {
    fill(1);
  }

  int fill(int need) {
    if (eof_) {
      return 1;
    }

    auto free = token_ - &buffer_[0];
    if (free < need) {
      buffer_size_ = (buffer_size_ + need) * 2;
      auto new_buffer = std::make_unique<unsigned char[]>(buffer_size_);
      std::memcpy(&new_buffer[0], token_, limit_ - token_);
      buffer_ = std::move(new_buffer);
    } else {
      std::memmove(&buffer_[0], token_, limit_ - token_);
    }
    cursor_ = &buffer_[0] + (cursor_ - token_);
    marker_ = &buffer_[0] + (marker_ - token_);
    limit_ = &buffer_[0] + (limit_ - token_);
    token_ = &buffer_[0];

    fs_.read((char*)limit_, buffer_size_ - (limit_ - token_));
    limit_ += fs_.gcount();
    if (fs_.eof()) {
      eof_ = true;
      std::memset(limit_, 0, YYMAXFILL);
      limit_ += YYMAXFILL;
    }
    return 0;
  }

  std::size_t length() { return cursor_ - token_; }

  std::string text() { return std::string(token_, token_ + length()); }

  int scan() {
  loop:
    token_ = cursor_;

    
    {
      unsigned char yych;
      if (limit_ <= cursor_) if (fill(1) != 0) return -1;
      yych = *cursor_;
      switch (yych) {
      case 0x00:  goto yy2;
      case '\t':
      case '\f':
      case '\r':
      case ' ':  goto yy6;
      case '\n':  goto yy8;
      case '*':  goto yy10;
      case '+':  goto yy12;
      case '-':  goto yy14;
      case '/':  goto yy16;
      case '0':  goto yy18;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':  goto yy20;
      default:  goto yy4;
      }
yy2:
      ++cursor_;
      { return kEOF; }
yy4:
      ++cursor_;
      { return kError; }
yy6:
      ++cursor_;
      {
        goto loop;
    }
yy8:
      ++cursor_;
      {
      return kNewline;
    }
yy10:
      ++cursor_;
      {
      return kMul;
    }
yy12:
      ++cursor_;
      {
      return kAdd;
    }
yy14:
      ++cursor_;
      {
      return kSub;
    }
yy16:
      ++cursor_;
      {
      return kDiv;
    }
yy18:
      ++cursor_;
yy19:
      {
      return kInt;
    }
yy20:
      ++cursor_;
      if (limit_ <= cursor_) if (fill(1) != 0) return -1;
      yych = *cursor_;
      switch (yych) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':  goto yy20;
      default:  goto yy19;
      }
    }

  }

 private:
  std::ifstream fs_;
  bool eof_;
  std::size_t buffer_size_;
  std::unique_ptr<unsigned char[]> buffer_;
  unsigned char* cursor_;
  unsigned char* marker_;
  unsigned char* token_;
  unsigned char* limit_;
};

class ParseError : public std::runtime_error {
 public:
  explicit ParseError(const std::string& what_arg)
      : std::runtime_error(what_arg) {}
};

class Parser {
 public:
  Parser(Scanner&& scanner) : scanner_(std::move(scanner)), tok_(-1) {}

  int peek() {
    if (tok_ == -1) {
      tok_ = scanner_.scan();
    }
    return tok_;
  }

  void consume() { tok_ = -1; }

  int factor() {
    auto tok = peek();
    if (tok == kInt) {
      consume();
      return std::atoi(scanner_.text().c_str());
    }
    throw ParseError("unexpected token");
  }

  int term() {
    auto x = factor();
    auto tok = peek();
    while (tok == kMul || tok == kDiv) {
      consume();
      auto y = factor();
      if (tok == kMul)
        x *= y;
      if (tok == kDiv)
        x /= y;
      tok = peek();
    }
    return x;
  }

  int expr() {
    auto x = term();
    auto tok = peek();
    while (tok == kAdd || tok == kSub) {
      consume();
      auto y = term();
      if (tok == kAdd)
        x += y;
      if (tok == kSub)
        x -= y;
      tok = peek();
    }
    return x;
  }

  bool parse() {
    auto tok = peek();
    while (tok == kNewline) {
      consume();
      tok = peek();
    }
    if (tok == kEOF) {
      return false;
    }
    auto x = expr();
    std::cout << x << std::endl;
    return true;
  }

 private:
  Scanner scanner_;
  int tok_;
};

int main(int argc, char** argv) {
  if (argc != 2) {
    std::cerr << "usage: " << argv[0] << " FILE" << std::endl;
    std::exit(1);
  }
  std::string filename(argv[1]);
  std::ifstream ifs(filename, std::ios::in | std::ios::binary);
  if (!ifs) {
    std::cerr << "failed to open" << filename << std::endl;
    std::exit(1);
  }
  Scanner scanner(std::move(ifs));
  Parser parser(std::move(scanner));
  while (parser.parse()) {}
  return 0;
}
